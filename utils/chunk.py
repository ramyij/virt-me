import os
import pathlib
from langchain_community.document_loaders import DirectoryLoader, TextLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain_core.documents import Document
import sys

# --- Configuration ---
# Assume the script is run from the project root
PROJECT_ROOT = pathlib.Path(__file__).parent.parent.resolve()
DATA_PATH = PROJECT_ROOT / "data"
OUTPUT_FILE = PROJECT_ROOT / "utils" / "chunked_data.py"
CHUNK_SIZE = 1000
CHUNK_OVERLAP = 200

def format_content_for_python_string(content: str) -> str:
    """Formats content to be safely included in a Python f-string literal."""
    # Replace backslashes first to avoid double escaping
    content = content.replace('\\', '\\\\')
    # Escape double quotes
    content = content.replace('"', '\\"')
    # Replace newline characters with literal \n
    content = content.replace('\n', '\\n')
    # Replace carriage returns potentially missed
    content = content.replace('\r', '\\r')
    return content

def main():
    print(f"Looking for raw text files in: {DATA_PATH}")
    if not DATA_PATH.is_dir():
        print(f"Error: Data directory not found at {DATA_PATH}. Please create it and add .txt files.")
        sys.exit(1)

    # --- Load Text files (.txt) ---
    print("Loading text (.txt) files...")
    try:
        text_loader_instance = DirectoryLoader(
            path=str(DATA_PATH),
            glob="**/*.txt", # Only looking for .txt files
            loader_cls=TextLoader,
            loader_kwargs={'encoding': 'utf-8'},
            use_multithreading=True,
            show_progress=True,
            recursive=True,
            silent_errors=True,
        )
        loaded_text_docs = text_loader_instance.load()
        if not loaded_text_docs:
            print("No .txt documents found or loaded. Exiting.")
            # Create an empty output file if no input docs found
            with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
                 f.write("from langchain_core.documents import Document\n\n")
                 f.write("# No text files found in the data directory\n")
                 f.write("text_chunks = []\n")
            print(f"Created empty output file: {OUTPUT_FILE}")
            sys.exit(0) # Exit successfully after creating empty file
        print(f"Successfully loaded {len(loaded_text_docs)} text documents.")

    except Exception as e:
        print(f"An error occurred while loading text files: {e}")
        sys.exit(1)

    # --- Split the loaded documents ---
    print(f"Splitting {len(loaded_text_docs)} loaded documents...")
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=CHUNK_SIZE,
        chunk_overlap=CHUNK_OVERLAP,
        length_function=len,
        add_start_index=True, # Often helpful metadata
    )
    split_docs = text_splitter.split_documents(loaded_text_docs)
    print(f"Created {len(split_docs)} chunks.")

    # --- Write chunks to the output file ---
    print(f"Writing {len(split_docs)} chunks to {OUTPUT_FILE}...")
    try:
        with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
            f.write("from langchain_core.documents import Document\n\n")
            f.write("# This file is auto-generated by utils/chunk.py\n")
            f.write("# Do not edit this file manually.\n\n")
            f.write("text_chunks = [\n")
            for i, doc in enumerate(split_docs):
                # Format page content carefully for Python string literal
                formatted_content = format_content_for_python_string(doc.page_content)
                # Use repr() for metadata, as it's usually safe for dicts
                metadata_repr = repr(doc.metadata)
                f.write(f'    Document(page_content="{formatted_content}", metadata={metadata_repr})')
                if i < len(split_docs) - 1:
                    f.write(",\n") # Add comma and newline for all but the last item
                else:
                    f.write("\n") # Just a newline for the last item
            f.write("]\n")
        print("Successfully wrote chunks to output file.")
    except Exception as e:
        print(f"An error occurred while writing the output file: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 